#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     IRseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          arm,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     RM,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LM,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     RF,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     LF,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     RB,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     LB,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define JOY_THRESH 12

int gyroOffset = 594;			// set default value

float gyroVal = 0.0;

int gyroCal()
{
	int sum = 0;

	// Take 50 readings and average them out
	for (int i = 0; i < 50; i++)
	{
		sum += SensorValue(S2);
		wait1Msec(5);
	}

	// Store new offset
	gyroOffset = (sum / 50.0);

	ClearTimer(T2);			// reset gyro timer

	// Return new offset value
	return gyroOffset;
}

float updateGyro()
{
	if( time1[T2] > 4 )
	{
		int gVal = SensorValue(S2) - gyroOffset;
		if( motor[LM] != 0 || motor[RM] != 0 )
			gyroVal += (time1[T2] * gVal) / 1000.0;
		ClearTimer(T2);														// reset gyro timer
	}
	return gyroVal;
}

void resetGyro()
{
	gyroVal = 0;
	ClearTimer(T2);
}

void advancedMotion()
{
	nMotorEncoder[RM] = 0;
	while(nMotorEncoder[RM] < 25100)
	{
		if(joy1Btn(3))
			break;
		else
		{
			motor[RM] = 25;
			motor[RF] = 25;
			motor[RB] = 25;
			motor[LF] = -25;
			motor[LM] = -25;
			motor[LB] = -25;
		}
	}
	nMotorEncoder[RM] = 0;
	nMotorEncoder[LM] = 0;
	while(nMotorEncoder[RM] > -2100 && nMotorEncoder[LM] > -2100)
	{
		if(joy1Btn(3))
			break;
		else
		{
			motor[RM] = -25;
			motor[LM] = -25;
		}
	}
	nMotorEncoder[RM] = 0;
	nMotorEncoder[LM] = 0;
	while(nMotorEncoder[RM] < 10000)
	{
		if(joy1Btn(3))
			break;
		else
		{
			motor[RM] = 25;
			motor[RF] = 25;
			motor[RB] = 25;
			motor[LF] = -25;
			motor[LM] = -25;
			motor[LB] = -25;
		}
	}
	nMotorEncoder[RM] = 0;
	nMotorEncoder[LM] = 0;
	while(nMotorEncoder[RM] < 1900 && nMotorEncoder[LM] < 1900)
	{
		if(joy1Btn(3))
			break;
		else
		{
			motor[RM] = 25;
			motor[LM] = 25;
		}
	}
	nMotorEncoder[RM] = 0;
	nMotorEncoder[LM] = 0;
	while(nMotorEncoder[RM] < 6000)
	{
		if(joy1Btn(3))
			break;
		else
		{
			motor[RM] = 25;
			motor[RF] = 25;
			motor[RB] = 25;
			motor[LF] = -25;
			motor[LM] = -25;
			motor[LB] = -25;
		}
	}
}

task main()
{

	waitForStart();

	int power = 0;
	int pause = 0;

	while(1)
	{

		getJoystickSettings(joystick);

		if( joy2Btn(1) == 1 )
		{
			pause = 0;
		}
		if( joy2Btn(2) == 1 || pause )
		{
			motor[LF] = 0;
			motor[LM] = 0;
			motor[LB] = 0;
			motor[RF] = 0;
			motor[RM] = 0;
			motor[RB] = 0;
			pause = 1;
			continue;
		}
		if(joy1Btn(2))
			motor[arm] = 75;
		else if(joy1Btn(4))
			motor[arm] = -75;
		else
			motor[arm] = 0;
		//if(joy1Btn(1))
		//	advancedMotion();

		if(abs(joystick.joy1_x2) > JOY_THRESH) //turn
		{
			power = joystick.joy1_x2/2;
			power = -power;
			motor[LM] = power;
			motor[RM] = power;
		}
		else if(abs(joystick.joy1_y1) > JOY_THRESH) //straight
		{
			power = joystick.joy1_y1;
			power = -power;
			motor[LF] = power;
			motor[LM] = power;
			motor[LB] = power;
			motor[RF] = -1 * power;
			motor[RM] = -1 * power;
			motor[RB] = -1 * power;
		}
		else
		{
			motor[LF] = 0;
			motor[LM] = 0;
			motor[LB] = 0;
			motor[RF] = 0;
			motor[RM] = 0;
			motor[RB] = 0;
		}
	}

}
