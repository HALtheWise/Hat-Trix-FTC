#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     seeker,         sensorI2CCustom)
#pragma config(Motor,  motorA,          wrist1,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          wrist2,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     tailwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     hookwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arms,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     stick,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#include "drivers/hitechnic-irseeker-v2.h"


#define DIST_SCALAR 465

int gyroOffset = 594;			// set default value

float gyroVal = 0.0;

int gyroCal()
{
	int sum = 0;

	// Take 50 readings and average them out
	for (int i = 0; i < 50; i++)
	{
		sum += SensorValue(S3);
		//writeDebugStreamLine("SensorValue(S3): %d", SensorValue(S3) );
		wait1Msec(5);
	}

	// Store new offset
	gyroOffset = (sum / 50.0);

	ClearTimer(T2);			// reset gyro timer

	// Return new offset value
	return gyroOffset;
}

float updateGyro()
{
	if( time1[T2] > 4 )
	{
		int gVal = SensorValue(S3) - gyroOffset;
		if( motor[FL] != 0 || motor[BR] != 0 )
			gyroVal += (time1[T2] * gVal) / 1000.0;
		//writeDebugStreamLine( "updateGyro gyroVal: %f gVal: %d Timer: %d", gyroVal, gVal, time1[T2] );
		ClearTimer(T2);	// reset gyro timer
	}
	return gyroVal;
}

void resetGyro()
{
	gyroVal = 0;
	ClearTimer(T2);
}

void turn( int deg, int power )
{
	resetGyro();
	if( deg > 0 )
		power = -1 * power;

	while( abs(gyroVal) < abs(deg) )
	{
		motor[FL] = power;
		motor[BL] = power;
		motor[FR] = power;
		motor[BR] = power;
		updateGyro();
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void move( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;

		//writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -power * mult;
		motor[BL] = -power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

int getSeeker()
{
	int _dirDC = 0;
	int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	// set the DSP to the new mode
	if ( ! HTIRS2setDSPMode(seeker, DSP_1200))
		return -1; // Sensor initialized

	// Read the current non modulated signal direction
	_dirDC = HTIRS2readDCDir(seeker);
	if (_dirDC < 0)
		return -1; // I2C read error occurred

	// read the current modulated signal direction
	_dirAC = HTIRS2readACDir(seeker);
	if (_dirAC < 0)
		return -1; // I2C read error occurred

	// Read the individual signal strengths of the internal sensors
	// Do this for both unmodulated (DC) and modulated signals (AC)
	if (!HTIRS2readAllDCStrength(seeker, dcS1, dcS2, dcS3, dcS4, dcS5))
		return -1; // I2C read error occurred
	if (!HTIRS2readAllACStrength(seeker, acS1, acS2, acS3, acS4, acS5 ))
		return -1; // I2C read error occurred

	writeDebugStreamLine("D %d %d", _dirDC, _dirAC);
	writeDebugStreamLine("0 %d %d", dcS1, acS1);
	writeDebugStreamLine("1 %d %d", dcS2, acS2);
	writeDebugStreamLine("2 %d %d", dcS3, acS3);
	writeDebugStreamLine("3 %d %d", dcS4, acS4);
	writeDebugStreamLine("4 %d %d", dcS5, acS5);

	if(acS3 > 100 && acS2 < 50 && acS4 < 50)
		return 1;
	else
		return 0;

}

void adjustedMove( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;

		//writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -1.5 * power * mult;
		motor[BL] = -1.5 * power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void pmove( long dist, int left, int right )
{
	int mult;
	long deg;
	deg = (dist * DIST_SCALAR)/10;
	if( dist < 0 )
		mult = 1;
	else
		mult = -1;
	nMotorEncoder[BR] = 0;
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		motor[FR] = right * -mult;
		motor[BR] = right * -mult;
		motor[FL] = left * mult;
		motor[BL] = left * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void dump(int left)
{
	int mult = 1;
	if(left)
		mult = -1;
	else
		mult = 1;
	adjustedMove(mult * 20, 20);
	turn(90, 30);
	while(nMotorEncoder[wrist1] > -400)
	{
		motor[wrist1] = -50;
		motor[wrist2] = -50;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
}

int* getButtons()
{
	static int buttons[] = {0,0,0,0};

	//Get touch sensor inputs
	long value = 1023-SensorRaw(S2);
	long switches = 339 * value;
	switches /= (1023-value);
	switches += 5;
	switches /= 10;
	if(switches&8)
		buttons[0] = 1;
	else
		buttons[0] = 0;
	if(switches&4)
		buttons[1] = 1;
	else
		buttons[1] = 0;
	if(switches&2)
		buttons[2] = 1;
	else
		buttons[2] = 0;
	if(switches&1)
		buttons[3] = 1;
	else
		buttons[3] = 0;
	writeDebugStreamLine("switch1: %d" , buttons[0]);
	writeDebugStreamLine("switch2: %d" , buttons[1]);
	writeDebugStreamLine("switch3: %d" , buttons[2]);
	writeDebugStreamLine("switch4: %d" , buttons[3]);

	return buttons;
}

void IRramp(int left , int delay)
{
	int mult = 1;
	int beacon = 0;
	if(left)
		mult = - 1;
	else
		mult = 1;
	int boost = 0;
	if(delay)
	{
		wait1Msec(5000);
		boost = 20;
	}
	else
		boost = 0;

	if(!left)
	{
		//Raise the arm
		while(nMotorEncoder[arms] > -4500)
		{
			motor[arms] = -30;
		}
		motor[arms] = 0;
		adjustedMove(mult * 19, 20 + boost);
		wait10Msec(25);
	}
	else
	{
		move(mult * 40, 20 + boost);
		wait10Msec(25);
		while(nMotorEncoder[arms] > -5100)
		{
			motor[arms] = -30;
		}
		motor[arms] = 0;

	}

	if(getSeeker())
	{
		beacon = 1;
		writeDebugStreamLine("found becon at 1");
		dump(left);
	}

	if(!beacon)
	{
		adjustedMove(mult * 20, 20 + boost);
		wait1Msec(250);
		if(getSeeker() && !beacon)
		{
			beacon = 2;
			writeDebugStreamLine("found becon at 2");
			dump(left);
		}
		if(!beacon)
		{
			adjustedMove( mult * 45, 20 + boost);
			wait10Msec(25);
			if(getSeeker() && !beacon)
			{
				beacon = 3;
				writeDebugStreamLine("found becon at 3");
				dump(left);
			}
			if(!beacon)
			{
				adjustedMove(mult * 30, 20 + boost);
				wait10Msec(25);
				beacon = 4;
				writeDebugStreamLine("found becon at 4");
				dump(left);
			}
		}
	}
	wait10Msec(50);
	int add = 0;
	if(beacon == 1)
		add = 100;
	else if(beacon == 2)
		add = 75;
	else if(beacon == 3)
		add = 25;
	else
		add = 0;

	if(left)
		add += 20;

	//lift the wrist back up
	while(nMotorEncoder[wrist1] < -5)
	{
		motor[wrist1] = 20;
		motor[wrist2] = 20;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	turn(-90, 30 + boost);

	while(nMotorEncoder[arms] < -250)
	{
		motor[arms] = 40;
	}
	motor[arms] = 0;
	//drive to end of baskets
	move(mult * (15+add), 50 + boost);
	turn(mult * 45, 50 );
	move(mult * 25, 50 + boost);
	turn(mult * 30, 50 );
	move(mult * 80, 50 + boost);
	turn(-90, 50 + boost);
	//Drive onto ramp
	move(-50, 70 + boost);
	move(-40, 90);
}

void EndDump(int left, int delay)
{
	int mult = -1;

	if(left)
		mult = 1;
	else
		mult = -1;

	int boost = 0;
	if(delay)
	{
		wait1Msec(10000);
		boost = 20;
	}

	//Raise the arm
	while(nMotorEncoder[arms] > -5100)
	{
		motor[arms] = -30;
	}
	motor[arms] = 0;

	move(20, 25 + boost);

	while(nMotorEncoder[wrist1] > -400)
	{
		motor[wrist1] = -50;
		motor[wrist2] = -50;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	wait1Msec(100);

	move(-15, 40 + boost);

	while(nMotorEncoder[wrist1] < -5)
	{
		motor[wrist1] = 20;
		motor[wrist2] = 20;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	while(nMotorEncoder[arms] < -250)
	{
		motor[arms] = 40;
	}
	motor[arms] = 0;

	turn(mult * 90, 40 + boost);
	move(-60, 40 + boost);
	turn(mult * 70, 40 + boost);
	move(-30, 40 + boost);
	move(-70, 90);

}

void Ramp(int left, int delay)
{
	int mult = -1;
	if(left)
		mult = 1;
	else
		mult = -1;

	if(delay)
		wait1Msec(10000);

	move(-100, 75);
	turn(mult * 30, 75);
	move(-70, 90);
}

////////////////////////////////////////////////////////////////////////////// TASK MAIN!!! \(^0^)/
task main()
{
	clearDebugStream();
	gyroCal();
	getSeeker();
	int left = 0;
	int delay = 0;
	int endDump = 0;
	int ramp = 0;

	int* switches = getButtons();

	if(switches[3])
		left = 1;
	else
		left = 0;

	if(switches[2])
		delay = 1;
	else
		delay = 0;

	if(switches[1])
		endDump = 1;
	else
		endDump = 0;

	if(switches[0])
		ramp = 1;
	else
		ramp = 0;

	//Round starts here
	waitForStart();

	nMotorEncoder[BR] = 0;
	nMotorEncoder[wrist1] = 0;
	nMotorEncoder[arms] = 0;

	if(endDump)
		EndDump(left, delay);

	else if(ramp)
		Ramp(left, delay);

	else
		IRramp(left , delay);


}
