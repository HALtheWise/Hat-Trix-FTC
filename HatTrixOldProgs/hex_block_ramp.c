#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          wrist1,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          wrist2,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     tailwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     hookwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arms,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     stick,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define DIST_SCALAR 1136

#define STALL_VALUE  12

#define CHECK_TIME  40


int gyroOffset = 594;			// set default value

float gyroVal = 0.0;

void carryArm( int button, int up, int down)
{
	static int HIGH_ARM_VALUE = 1400;
	static int LOW_ARM_VALUE = 1375;
	static int timesStill = 0;
	static int lastPositon = 0;
	static int armPower = 0;
	static int lastButton = 0;
	int curPositon = nMotorEncoder[arms];

	if(curPositon < 0)
		nMotorEncoder[arms] = 0;

	if(up)
	{
		HIGH_ARM_VALUE += 5;
		LOW_ARM_VALUE += 5;
	}

	if(down)
	{
		HIGH_ARM_VALUE -= 5;
		LOW_ARM_VALUE -= 5;

	}

	if(!button) // the button wasn't pressed
	{
		if(lastButton) // and the last time it was: reset everything
		{
			motor[arms] = 0;
			timesStill = 0;
			lastPositon = curPositon;
			armPower = 0;
			lastButton = 0;
		}
		return;
	}

	//	writeDebugStreamLine("curPositon %d" , curPositon);

	if(!lastButton)
	{
		timesStill = 0;
		lastPositon = curPositon;

		if(curPositon >= LOW_ARM_VALUE)
		{
			timesStill = 0;
			lastPositon = curPositon;
			armPower = 0;
			motor[arms] = armPower;
			return;
		}
	}
	lastButton = button;


	if( time1[T1] > CHECK_TIME ) // if its time to check
	{
		ClearTimer(T1);
		if(curPositon >= HIGH_ARM_VALUE)
		{
			timesStill = 0;
			lastPositon = curPositon;
			armPower = 0;
			motor[arms] = armPower;
			return;
		}

		if(curPositon <= LOW_ARM_VALUE && armPower == 0 && timesStill < STALL_VALUE)
		{
			timesStill = 0;
			lastPositon = curPositon;
			armPower = 40;
			writeDebugStream("set power %d timesStill %d \n", armPower, timesStill);
			motor[arms] = armPower;
			return;
		}

		int change = lastPositon - curPositon;
		writeDebugStream("set power %d timesStill %d change %d encoder %d \n", armPower , timesStill , change, curPositon);


		if( timesStill > STALL_VALUE ) // if it hasnt moved in the past few iterations
		{
			armPower = 0;
			motor[arms] = armPower;
			timesStill ++;
			return;
		}

		if(change < 1)
		{
			timesStill ++;
			armPower = 100;
			writeDebugStream("set power %d timesStill %d change %d \n", armPower , timesStill, change);
			motor[arms] = armPower;
			lastPositon = curPositon;
			return;
		}

		lastPositon = curPositon;
		timesStill = 0;

		//if(nMotorEncoder[arms] >= CARRY_ENCODER_VALUE) // if it has reached the point it should be at
		//{
		//	motor[arms] = 0;
		//	timesStill = 0;
		//	return;
		//}

		//if(nMotorEncoder[arms] < CARRY_ENCODER_VALUE) // if it hasnt gotten there yet
		//{
		//	if((nMotorEncoder[arms] - lastPositon) > 0) // if it moved last time: just keep going
		//	{
		//		timesStill = 0;
		//		return;
		//	}
		//	else // if it hasnt moved but power was applied
		//	{
		//		armPower += 5; // add power
		//		timesStill += 1; // and increment the variable
		//	}
		//	motor[arms] = armPower;
		//}


	}

	return;

}

void carryWrist( int button)
{
	static int wristTarget = 0;
	static int lastButton = 0;
	static int startPosition = 0;

	if(!button)
	{
		if(lastButton)
		{
			motor[wrist1] = 0;
			motor[wrist2] = 0;
			lastButton = 0;
		}
		return;
	}

	if(!lastButton)
	{
		nMotorEncoder[wrist1] = 0;
		startPosition = nMotorEncoder[arms];
	}
	lastButton = button;
	wristTarget = (nMotorEncoder[arms] - startPosition)/9;

	if(button)
	{

		if(joy2Btn(2) || joy2Btn(4))
			return;

		if(nMotorEncoder[wrist1] > (wristTarget + 2))
		{
			motor[wrist1] = -50;
			motor[wrist2] = -50;
			return;
		}

		if(nMotorEncoder[wrist1] < (wristTarget - 2))
		{
			motor[wrist1] = 50;
			motor[wrist2] = 50;
			return;
		}

		else
		{
			motor[wrist1] = 0;
			motor[wrist2] = 0;
			return;
		}
	}
}

int gyroCal()
{
	int sum = 0;

	// Take 50 readings and average them out
	for (int i = 0; i < 50; i++)
	{
		sum += SensorValue(S3);
		writeDebugStreamLine("SensorValue(S3): %d", SensorValue(S3) );
		wait1Msec(5);
	}

	// Store new offset
	gyroOffset = (sum / 50.0);

	ClearTimer(T2);			// reset gyro timer

	// Return new offset value
	return gyroOffset;
}

float updateGyro()
{
	if( time1[T2] > 4 )
	{
		int gVal = SensorValue(S3) - gyroOffset;
		if( motor[FL] != 0 || motor[BR] != 0 )
			gyroVal += (time1[T2] * gVal) / 1000.0;
		//writeDebugStreamLine( "updateGyro gyroVal: %f gVal: %d Timer: %d", gyroVal, gVal, time1[T2] );
		ClearTimer(T2);	// reset gyro timer
	}
	return gyroVal;
}

void resetGyro()
{
	gyroVal = 0;
	ClearTimer(T2);
}

void turn( int deg, int power )
{
	resetGyro();
	if( deg > 0 )
		power = -1 * power;

	while( abs(gyroVal) < abs(deg) )
	{
		motor[FL] = power;
		motor[BL] = power;
		motor[FR] = power;
		motor[BR] = power;
		updateGyro();
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void move( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;

		writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -power * mult;
		motor[BL] = -power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void armMove( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;
		carryArm(1,0,0);

		writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -power * mult;
		motor[BL] = -power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

task main()
{
	int mult = 0;
	clearDebugStream();
	gyroCal();
	if(SensorValue(S2))
		mult = -1;
	else
		mult = 1;
	waitForStart();
	nMotorEncoder[BR] = 0;
	nMotorEncoder[wrist1] = 0;
	nMotorEncoder[arms] = 0;
	while(nMotorEncoder[arms] < 1550)
	{
		if(nMotorEncoder[wrist1] < 120)
		{
			motor[wrist1] = 50;
			motor[wrist2] = 50;
		}
		else
		{
			motor[wrist1] = 0;
			motor[wrist2] = 0;
		}

		motor[arms] = 50;
	}
	motor[arms] = 0;

	armMove(20, 25);

	while(nMotorEncoder[wrist1] < 400)
	{
		carryArm(1,0,0);
		motor[wrist1] = 50;
		motor[wrist2] = 50;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	armMove(-15, 25);
	while(nMotorEncoder[wrist1] > 100)
	{
		motor[wrist1] = -50;
		motor[wrist2] = -50;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	motor[arms] = -10;
	wait10Msec(20);
	motor[arms] = 0;
	turn(mult * 90, 25);
	move(-40, 25);
	turn(mult * 75, 25);
	move(-30, 25);
	move(-70, 90);

}
