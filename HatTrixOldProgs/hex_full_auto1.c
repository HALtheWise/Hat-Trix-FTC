#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     seeker,         sensorI2CCustom)
#pragma config(Motor,  motorA,          wrist1,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          wrist2,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     tailwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     hookwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arms,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     stick,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#include "drivers/hitechnic-irseeker-v2.h"


#define DIST_SCALAR 465

int gyroCal();
float updateGyro();
void resetGyro();
int* getButtons();
void turn(int deg, int power);
void move( long dist, int power );
int getSeeker();
void adjustedMove( long dist, int power );
void pmove( long dist, int left, int right );
void dump();

int gyroOffset = 594;			// set default value

float gyroVal = 0.0;

task main()
{
	clearDebugStream();
	gyroCal();
	getSeeker();

	//Get touch sensor inputs
	int* switches = getButtons();
	writeDebugStreamLine("switches = {%d, %d, %d, %d}", switches[0], switches[1], switches[2], switches[3]);


	//Round starts here
	waitForStart();

	nMotorEncoder[BR] = 0;
	nMotorEncoder[wrist1] = 0;
	nMotorEncoder[arms] = 0;
	int beacon = 0;

	//Raise the arm
	while(nMotorEncoder[arms] > -5100)
	{
		motor[arms] = -30;
	}
	motor[arms] = 0;
	adjustedMove(24, 20);
	wait10Msec(10);
	if(getSeeker())
	{
		beacon = 1;
		writeDebugStreamLine("found becon at 1");
		dump();
	}

	if(!beacon)
	{
		wait1Msec(100);
		adjustedMove(18, 20);
		wait1Msec(100);
		if(getSeeker() && !beacon)
		{
			beacon = 2;
			writeDebugStreamLine("found becon at 2");
			dump();
		}
		if(!beacon)
		{
			wait10Msec(10);
			adjustedMove(60, 20);
			wait10Msec(10);
			if(getSeeker() && !beacon)
			{
				beacon = 3;
				writeDebugStreamLine("found becon at 3");
				dump();
			}
			if(!beacon)
			{
				wait10Msec(10);
				adjustedMove(18, 20);
				wait10Msec(10);
				beacon = 4;
				writeDebugStreamLine("found becon at 4");
				dump();
			}
		}
	}
	wait10Msec(50);
	int add = 0;
	if(beacon == 1)
		add = 96;
	else if(beacon == 2)
		add = 78;
	else if(beacon == 3)
		add = 18;
	else
		add = 0;
	//lift the wrist back up
	while(nMotorEncoder[wrist1] < -5)
	{
		motor[wrist1] = 20;
		motor[wrist2] = 20;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
	turn(-90, 30);

	while(nMotorEncoder[arms] < -250)
	{
		motor[arms] = 40;
	}
	//drive to end of baskets
	move(20+add, 50);
	turn(45, 50);
	move(20, 50);
	turn(45, 50);
	move(80, 50);
	turn(-90, 50);
	//Drive onto ramp
	move(-50, 50);
	move(-30, 90);
}

int* getButtons()
{
	static int buttons[] = {0,0,0,0};
	clearDebugStream();
	gyroCal();
	getSeeker();

	//Get touch sensor inputs
	long value = 1023-SensorRaw(S2);
	long switches = 339 * value;
	switches /= (1023-value);
	switches += 5;
	switches /= 10;
	if(switches&8)
		buttons[0] = 1;
	else
		buttons[0] = 0;
	if(switches&4)
		buttons[1] = 1;
	else
		buttons[1] = 0;
	if(switches&2)
		buttons[2] = 1;
	else
		buttons[2] = 0;
	if(switches&1)
		buttons[3] = 1;
	else
		buttons[3] = 0;
	writeDebugStreamLine("switch1: %d" , buttons[0]);
	writeDebugStreamLine("switch2: %d" , buttons[1]);
	writeDebugStreamLine("switch3: %d" , buttons[2]);
	writeDebugStreamLine("switch4: %d" , buttons[3]);

	return buttons;
}

int gyroCal()
{
	int sum = 0;

	// Take 50 readings and average them out
	for (int i = 0; i < 50; i++)
	{
		sum += SensorValue(S3);
		//writeDebugStreamLine("SensorValue(S3): %d", SensorValue(S3) );
		wait1Msec(5);
	}

	// Store new offset
	gyroOffset = (sum / 50.0);

	ClearTimer(T2);			// reset gyro timer

	// Return new offset value
	return gyroOffset;
}

float updateGyro()
{
	if( time1[T2] > 4 )
	{
		int gVal = SensorValue(S3) - gyroOffset;
		if( motor[FL] != 0 || motor[BR] != 0 )
			gyroVal += (time1[T2] * gVal) / 1000.0;
		//writeDebugStreamLine( "updateGyro gyroVal: %f gVal: %d Timer: %d", gyroVal, gVal, time1[T2] );
		ClearTimer(T2);	// reset gyro timer
	}
	return gyroVal;
}

void resetGyro()
{
	gyroVal = 0;
	ClearTimer(T2);
}

void turn( int deg, int power )
{
	resetGyro();
	if( deg > 0 )
		power = -1 * power;

	while( abs(gyroVal) < abs(deg) )
	{
		motor[FL] = power;
		motor[BL] = power;
		motor[FR] = power;
		motor[BR] = power;
		updateGyro();
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void move( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;

		//writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -power * mult;
		motor[BL] = -power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

int getSeeker()
{
	int _dirDC = 0;
	int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	// set the DSP to the new mode
	if ( ! HTIRS2setDSPMode(seeker, DSP_1200))
		return -1; // Sensor initialized

	// Read the current non modulated signal direction
	_dirDC = HTIRS2readDCDir(seeker);
	if (_dirDC < 0)
		return -1; // I2C read error occurred

	// read the current modulated signal direction
	_dirAC = HTIRS2readACDir(seeker);
	if (_dirAC < 0)
		return -1; // I2C read error occurred

	// Read the individual signal strengths of the internal sensors
	// Do this for both unmodulated (DC) and modulated signals (AC)
	if (!HTIRS2readAllDCStrength(seeker, dcS1, dcS2, dcS3, dcS4, dcS5))
		return -1; // I2C read error occurred
	if (!HTIRS2readAllACStrength(seeker, acS1, acS2, acS3, acS4, acS5 ))
		return -1; // I2C read error occurred

	writeDebugStreamLine("D %d %d", _dirDC, _dirAC);
	writeDebugStreamLine("0 %d %d", dcS1, acS1);
	writeDebugStreamLine("1 %d %d", dcS2, acS2);
	writeDebugStreamLine("2 %d %d", dcS3, acS3);
	writeDebugStreamLine("3 %d %d", dcS4, acS4);
	writeDebugStreamLine("4 %d %d", dcS5, acS5);

	if(acS3 > 120 && acS2 < 50 && acS4 < 50)
		return 1;
	else
		return 0;

}

void adjustedMove( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10;
	if( dist > 0 )
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist);

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit)
			break;

		//writeDebugStreamLine( "encoder = %d degree = %d", nMotorEncoder[BR], deg);
		motor[FL] = -1.5 * power * mult;
		motor[BL] = -1.5 * power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void pmove( long dist, int left, int right )
{
	int mult;
	long deg;
	deg = (dist * DIST_SCALAR)/10;
	if( dist < 0 )
		mult = 1;
	else
		mult = -1;
	nMotorEncoder[BR] = 0;
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		motor[FR] = right * -mult;
		motor[BR] = right * -mult;
		motor[FL] = left * mult;
		motor[BL] = left * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

void dump()
{
	adjustedMove(20, 20);
	turn(90, 30);
	while(nMotorEncoder[wrist1] > -400)
	{
		motor[wrist1] = -50;
		motor[wrist2] = -50;
	}
	motor[wrist1] = 0;
	motor[wrist2] = 0;
}
