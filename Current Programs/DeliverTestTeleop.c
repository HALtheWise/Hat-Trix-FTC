#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     thing1,         sensorLightActive)
#pragma config(Sensor, S3,     thing2,         sensorI2CMuxController)
#pragma config(Motor,  motorA,          grabber1,      tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          grabber2,      tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     arm,           tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BackL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackR,         tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    latch,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define null (void *)0
#include "ButtonJoyDriver2.c"



#define AI_NONE 0
#define AI_DRIVE 1
#define AI_RTURN 2
#define AI_LTURN 3
#define AI_ARM 4
#define AI_ROLLER 5
#define AI_GRABBER 6
#define AI_ELEVATOR 7
#define AI_LATCH 8
#define AI_LADDER 9
#define AI_EXTENSION 10

#define MAX_RES 9 //Number of resources being tracked

#define RES_WHEELS 0 //This stuff should probably be an enum
#define RES_ROLLER 1
#define RES_ARM 2
#define RES_WINCH 3
#define RES_ELEV 4
#define RES_GRABBER 5
#define RES_LATCH 6
#define RES_LADDER 7
#define RES_EXTENSION 8

int res_owner[MAX_RES];
//int res_power[MAX_RES];

typedef enumWord{ C_EVENT, C_ABORT, C_RELEASE} Command;

//typedef enumWord{ACTION_DRIVE, ACTION_TRIGHT, ACTION_TLEFT} ACTION;

// typedef enumWord{ A_ACTIVE, A_INACTIVE, A_DONUT} ASTATE;

void command_all( Command cmd, EventList *eList, int res_id );

//void requestStateChange(int action, ASTATE newState)
//{
//}

int get_owner( int res_id )
{
	if( res_id >= 0 && res_id < MAX_RES )
		return res_owner[ res_id];
	else
		return AI_NONE;
}

void set_owner( int res_id, int owner )
{
	if( res_id >= 0 && res_id < MAX_RES )
		res_owner[ res_id ] = owner;

}

void request_ownage(int action, int res_id)
{
	if(get_owner(res_id)!= action && get_owner(res_id) != AI_NONE)//
	{
		command_all( C_RELEASE, null, res_id );
	}
	if( get_owner(res_id) == AI_NONE)
		set_owner( res_id, action );
}

void zeroHomeless()
{
	if( get_owner(RES_WHEELS) == AI_NONE)
	{
		motor[BackL] = 0;
		//motor[FrontL] = 0;
		motor[BackR] = 0;
		motor[FrontR] = 0;
	}
	if( get_owner(RES_ARM) == AI_NONE)
	{
		//motor[Arm] = 0;
	}
}


int isPressed( EventList *eList,  int event )
{
	for( int i=0; i < eList->eventCnt; i++ )
		if( eList->bevents[i] == event ){
		return 1;
	}
	return 0;
}



void actionArm(Command cmd, EventList *eList, int res_id )
{
	const int ARM_UP_POSITION = 0;
	const int ARM_DOWN_POSITION = -800;
	const int ARM_UP_POWER = 30;
	const int ARM_DOWN_POWER = -30;
	const int a_up = 0;
	const int a_dwn = 1;
	const int a_stop = -1;
	static int state = a_stop;
	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_ARM) == AI_ARM)
		{
			motor[arm] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionArm(C_ABORT, null, RES_ARM);
		return;
	case C_EVENT:
		request_ownage(AI_ARM , RES_ARM);

		if(get_owner(RES_ARM) == AI_ARM)
		{
			/*if( isPressed( eList, armUp )){
			writeDebugStreamLine("arm going up");
			motor[arm] = ARM_UP_POWER;
			state = a_up;
			ClearTimer(T2);
			}
			if( isPressed( eList, armDown ))	{
			writeDebugStreamLine("arm going down");
			motor[arm] = ARM_DOWN_POWER;
			state = a_dwn;
			ClearTimer(T2);
			}*/
			if(isPressed( eList, nudgeArmDown ))	{
				motor[arm] = ARM_DOWN_POWER;
			}
			if(isPressed( eList, nudgeArmUp ))	{
				motor[arm] = ARM_UP_POWER;
			}
			if( isPressed( eList, armStop ))	{
				motor[arm] = 0;
				state = a_stop;
			}
			/*if(state == a_up)
			{
			if(nMotorEncoder[arm] >= ARM_UP_POSITION || time1[T2] >= 1500)
			{
			motor[arm] = 0;
			state = a_stop;
			}
			}
			if(state == a_dwn)
			{
			if(nMotorEncoder[arm] <= ARM_DOWN_POSITION || time1[T2] >= 1500)
			{
			motor[arm] = 0;
			state = a_stop;
			}
			}*/


		}
		break;

	}


}

/*void actionRoller(Command cmd, EventList *eList, int res_id )
{
const int UP_POWER = -50;
const int DOWN_POWER = 50;
switch(cmd)
{
case C_ABORT:
if( get_owner(RES_ROLLER) == AI_ROLLER)
{
motor[rollers] = 0;
set_owner( res_id, AI_NONE );
return;
}
break;
case C_RELEASE:
actionRoller(C_ABORT, null, RES_ROLLER);
return;
case C_EVENT:
request_ownage(AI_ROLLER , RES_ROLLER);

if(get_owner(RES_ROLLER) == AI_ROLLER)
{
if( isPressed( eList, rollrStart )){
writeDebugStreamLine("arm going up");
motor[rollers] = UP_POWER;
}
if( isPressed( eList, rollrRvsStrt ))	{
writeDebugStreamLine("arm going down");
motor[rollers] = DOWN_POWER;
}
if( isPressed( eList, rollrStop ))	{
motor[rollers] = 0;
}
}
break;

}


}*/

void actionGrabber(Command cmd, EventList *eList, int res_id )
{
	const int UP_POWER = 50;
	const int DOWN_POWER = -70;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_GRABBER) == AI_GRABBER)
		{
			motor[grabber1] = 0;
			motor[grabber2] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionGrabber(C_ABORT, null, RES_GRABBER);
		return;
	case C_EVENT:
		request_ownage(AI_GRABBER , RES_GRABBER);

		if(get_owner(RES_GRABBER) == AI_GRABBER)
		{
			if( isPressed( eList, grab )){
				motor[grabber1] = DOWN_POWER;
				motor[grabber2] = DOWN_POWER;
				//state = g_down;
				//motor[grabber] = UP_POWER;
				//nMotorEncoder[grabber] = 0;
				//ClearTimer(T1);
			}
			if( isPressed( eList, release ))	{
				motor[grabber1] = UP_POWER;
				motor[grabber2] = UP_POWER;
				//state = g_up;
				//motor[grabber] = DOWN_POWER;
				//nMotorEncoder[grabber] = 0;
				//ClearTimer(T1);
			}
			if( isPressed( eList, stopGrab ))	{
				motor[grabber1] = 0;
				motor[grabber2] = 0;
				//state = g_up;
				//motor[grabber] = DOWN_POWER;
				//nMotorEncoder[grabber] = 0;
				//ClearTimer(T1);
			}
			/*if(state==g_down)
			{
			if(nMotorEncoder[grabber] >= 0 || time1[T1] >= 2000)
			{
			motor[grabber] = 0;
			state = g_hold;
			}
			}
			if(state == g_up)
			{
			if(nMotorEncoder[grabber] <= -140 || time1[T1] >= 2000)
			{
			motor[grabber] = 0;
			state = g_hold;
			}
			}*/
		}

		break;

	}


}

/*void actionElevator(Command cmd, EventList *eList, int res_id )
{
	const int CENTER_POSITION = 3300;
	const int HIGH_POSITION = 2400;
	const int MED_POSITION = 1500;
	const int LOW_POSITION = 50;
	const int DOWN_POWER = -30;
	const int UP_POWER = 50;
	const int e_down = 0;
	const int e_up = 1;
	const int e_stop =-1;
	static int state = e_stop;
	static int target = 0;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_ELEV) == AI_ELEVATOR)
		{
			motor[elevator] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionElevator(C_ABORT, null, RES_ELEV);
		return;
	case C_EVENT:
		request_ownage(AI_ELEVATOR , RES_ELEV);

		if(get_owner(RES_ELEV) == AI_ELEVATOR)
		{
			if( isPressed( eList, elevatorUp )){
				motor[elevator] = UP_POWER;
			}
			if(isPressed( eList, elevatorDown )){
				motor[elevator] = DOWN_POWER;
			}
			if(isPressed( eList, elvStop )){
				motor[elevator] = 0;
			}

			//if( isPressed( eList, elvLow )){

			//	if(nMotorEncoder[elevator] > LOW_POSITION)
			//	{
			//		motor[elevator] = DOWN_POWER;
			//		state = e_down;
			//		target = LOW_POSITION;
			//		ClearTimer(T1);
			//	}
			//}
			//if( isPressed( eList, elvMedium )){

			//	if(nMotorEncoder[elevator] > MED_POSITION)
			//	{
			//		motor[elevator] = DOWN_POWER;
			//		state = e_down;
			//		target = MED_POSITION;
			//		ClearTimer(T1);
			//	}
			//	else if(nMotorEncoder[elevator] < MED_POSITION)
			//	{
			//		motor[elevator] = UP_POWER;
			//		state = e_up;
			//		target = MED_POSITION;
			//		ClearTimer(T1);
			//	}
			//}
			//if( isPressed( eList, elvHigh )){

			//	if(nMotorEncoder[elevator] > HIGH_POSITION)
			//	{
			//		motor[elevator] = DOWN_POWER;
			//		state = e_down;
			//		target = HIGH_POSITION;
			//		ClearTimer(T1);
			//	}
			//	else if(nMotorEncoder[elevator] < HIGH_POSITION)
			//	{
			//		motor[elevator] = UP_POWER;
			//		state = e_up;
			//		target = HIGH_POSITION;
			//		ClearTimer(T1);
			//	}
			//}
			//if( isPressed( eList, elvCenter )){

			//	if(nMotorEncoder[elevator] < CENTER_POSITION)
			//	{
			//		motor[elevator] = UP_POWER;
			//		state = e_up;
			//		target = CENTER_POSITION;
			//		ClearTimer(T1);
			//	}
			//}
			//if( isPressed( eList, elvStop ))	{
			//	motor[elevator] = 0;
			//	state = e_stop;
			//}
			//if(state == e_down)
			//{
			//	if(nMotorEncoder[elevator] <= target || time1[T1] >= 4000)
			//	{
			//		motor[elevator] = 0;
			//		state = e_stop;
			//	}
			//}
			//if(state == e_up)
			//{
			//	if(nMotorEncoder[elevator] >= target || time1[T1]>= 4000)
			//	{
			//		motor[elevator] = 0;
			//		state = e_stop;
			//	}
			//}
		}

		break;

	}
}*/

void actionTakeADump(Command cmd, EventList *eList, int res_id)
{
	const int OPEN_POSITION = 130;
	const int CLOSED_POSITION = 145;
	const int open = 0;
	const int closed = 1;
	static int state = closed;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_LATCH) == AI_LATCH)
		{
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionTakeADump(C_ABORT, null, RES_LATCH);
		return;
	case C_EVENT:
		request_ownage(AI_LATCH , RES_LATCH);

		if(get_owner(RES_LATCH) == AI_LATCH)
		{
			if( isPressed( eList, takeADump )){
				servo[latch] = OPEN_POSITION;
				state = open;
				ClearTimer(T4);
			}

			if(state == open && time1[T4] >= 2000)
			{
				servo[latch] = CLOSED_POSITION;
				state = closed;
			}
		}

		break;

	}
}

/*void actionLadder(Command cmd, EventList *eList, int res_id)
{
	const int UP_POWER = -80;
	const int DOWN_POWER = 50;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_LADDER) == AI_LADDER)
		{
			motor[winch] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionLadder(C_ABORT, null, RES_LADDER);
		return;
	case C_EVENT:
		request_ownage(AI_LADDER , RES_LADDER);

		if(get_owner(RES_LADDER) == AI_LADDER)
		{
			if( isPressed( eList, ladUp )){
				motor[winch] = UP_POWER;
			}
			if(isPressed( eList, ladDown )){
				motor[winch] = DOWN_POWER;
			}
			if( isPressed( eList, ladStop )){
				motor[winch] = 0;
			}

		}

		break;

	}
}*/

/*void actionExtension(Command cmd, EventList *eList, int res_id)
{
const int UP_POWER = -100;

switch(cmd)
{
case C_ABORT:
if( get_owner(RES_EXTENSION) == AI_EXTENSION)
{
motor[extend1] = 0;
motor[extend2] = 0;
set_owner( res_id, AI_NONE );
return;
}
break;
case C_RELEASE:
actionExtension(C_ABORT, null, RES_EXTENSION);
return;
case C_EVENT:
request_ownage(AI_EXTENSION , RES_EXTENSION);

if(get_owner(RES_EXTENSION) == AI_EXTENSION)
{
if( isPressed( eList, extendLdr )){
motor[extend1] = UP_POWER;
motor[extend2] = UP_POWER;
}
if( isPressed( eList, stopExtension )){
motor[extend1] = 0;
motor[extend2] = 0;
}

}

break;

}
}*/


void actionTRight(Command cmd, EventList *eList, int res_id)
{
	// switch cmd

}

void actionTLeft(Command cmd, EventList *eList, int res_id)
{
	// switch cmd

}
float getMultiplier(EventList *eList)
{
	static float speedMultiplier = 1.0;

	if(isPressed(eList, normalSpd))
		speedMultiplier = 1.0;
	if(isPressed(eList, lessSpd))
		speedMultiplier = 0.25;
	if(isPressed(eList, moreSpd))
		speedMultiplier= 1.80;

	return speedMultiplier;
}

void actionDrive(Command cmd, EventList *eList, int res_id )
{
	static int waitingToDrive = 0;
	static int typeDrive = 0;
	static float lefty, righty;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_WHEELS) == AI_DRIVE)
		{
			motor[BackL] = 0;
			//motor[FrontL] = 0;
			motor[BackR] = 0;
			motor[FrontR] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		if(get_owner(res_id)== AI_DRIVE ){
			//stop driving
			set_owner( res_id, AI_NONE );
		}
		break;
	case C_EVENT:

		if(isPressed(eList, switchDrive))
			typeDrive = !typeDrive;

		if(get_owner(RES_WHEELS)!= AI_DRIVE && get_owner(RES_WHEELS) != AI_NONE)//request_ownage(AI_DRIVE,res_id))
		{
			command_all( C_RELEASE, null, RES_WHEELS );
		}
		if( get_owner(RES_WHEELS) == AI_NONE)
			set_owner( RES_WHEELS, AI_DRIVE );

		if(get_owner(RES_WHEELS) == AI_DRIVE)
		{
			if(typeDrive == 0)
			{
				/*if(abs(abs(((eList->joy1.y *100)/128)/2) - lefty) > abs(lefty/3))
				lefty += (((eList->joy1.y *100)/128)/2)/3;

				if(abs(abs(((eList->joy1.y *100)/128)/2) - righty) > abs(righty/3))
				righty += (((eList->joy1.y *100)/128)/2)/3;


				lefty += -((eList->joy2.x *100)/128)/2;
				righty += ((eList->joy2.x *100)/128)/2;*/

				lefty = righty = ((eList->joy2.y *100)/128);///2;


				lefty  +=  ((eList->joy1.x *100)/128);///2;
				righty += -((eList->joy1.x *100)/128);///2;

				if(true){ //invert front
					float temp;
					temp = lefty;
					lefty = -righty;
					righty = -temp;
				}
			}
			else if(typeDrive == 1)
			{
				lefty = -((eList->joy2.y *100)/128);///2;
				righty = -((eList->joy1.y *100)/128);///2;
			}

			lefty *= (float)getMultiplier(eList);
			righty *= (float)getMultiplier(eList);

			//motor[FrontL] =lefty;
			motor[BackL] = lefty;

			motor[BackR] = -righty;
			motor[FrontR] = -righty;

			//

			//motor[BackL] += -((eList->joy2.x *100)/128)/2;
			//motor[FrontL] += -((eList->joy2.x *100)/128)/2;

			//motor[BackR] += ((eList->joy2.x *100)/128)/2;
			//motor[FrontR] += ((eList->joy2.x *100)/128)/2;

			//motor[BackR] *= -1;
			//motor[FrontR] *= -1;
		}
		//


	}
}


void command_all( Command cmd, EventList *eList, int res_id )
{
	//if(res_id == RES_WHEELS)
	//{
	//	if(get_owner(res_id) != AI_DRIVE)
	//		res_owner[res_id] = AI_DRIVE;

	//	if(get_owner(res_id) == AI_DRIVE)
	//		actionDrive(cmd, eList, res_id);
	//}

	actionDrive(cmd, eList, res_id);
	//actionRoller(cmd, eList, res_id);
	actionGrabber(cmd, eList, res_id);
	actionArm(cmd, eList, res_id);
	//actionElevator(cmd, eList, res_id);
	actionTakeADump(cmd, eList, res_id);
	//actionLadder(cmd, eList, res_id);
	//actionExtension(cmd, eList, res_id);
	actionTRight( cmd, eList, res_id);
	actionTLeft( cmd, eList, res_id);
	zeroHomeless();
}

//void processAll(EventList *eList)
//{
//	if(abs(eList->joy1.y)>10 || abs(eList->joy2.x)>10
//		|| eList->bevents[1] || eList->bevents[3])
//		command_all( C_EVENT, eList, RES_WHEELS);
//	//*all the methods*(&eList);
//}

task main()
{
	waitForStart();
	EventList eList;

	clearDebugStream();
	ClearTimer(T1);
	ClearTimer(T2);
	ClearTimer(T4);

	while(1)
	{
		getEvents(&eList);
		if(!bDisconnected)
		{
			if(joy1Btn(10))
				nMotorEncoder[arm] = 0;

			command_all(C_EVENT, &eList, -1);
		}
		else
		{
			command_all(C_ABORT, &eList, -1);
		}

		//processDrive(&eList);

		//for(int i = 0; i<eventCnt;i++)
		//{
		//	switch(bevents[i].keyID){
		//		//case *name-of-button* :
		//		//*actions* ;
		//		//break;
		//	};
		//}



		//_________________________________________________________________________



	}
}
