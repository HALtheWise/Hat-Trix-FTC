#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     thing1,         sensorLightActive)
#pragma config(Sensor, S3,     thing2,         sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontL,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     winch,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     arm,           tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     rollers,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    grabber,              tServoStandard)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define null (void *)0
#include "ButtonJoyDriver.c"



#define AI_NONE 0
#define AI_DRIVE 1
#define AI_RTURN 2
#define AI_LTURN 3
#define AI_ARM 4
#define AI_ROLLER 5
#define AI_GRABBER 6

#define MAX_RES 6 //Number of resources being tracked

#define RES_WHEELS 0 //This stuff should probably be an enum
#define RES_ROLLER 1
#define RES_ARM 2
#define RES_WINCH 3
#define RES_ELEV 4
#define RES_GRABBER 5

int res_owner[MAX_RES];
//int res_power[MAX_RES];

typedef enumWord{ C_EVENT, C_ABORT, C_RELEASE} Command;

//typedef enumWord{ACTION_DRIVE, ACTION_TRIGHT, ACTION_TLEFT} ACTION;

// typedef enumWord{ A_ACTIVE, A_INACTIVE, A_DONUT} ASTATE;

void command_all( Command cmd, EventList *eList, int res_id );

//void requestStateChange(int action, ASTATE newState)
//{
//}

int get_owner( int res_id )
{
	if( res_id >= 0 && res_id < MAX_RES )
		return res_owner[ res_id];
	else
		return AI_NONE;
}

void set_owner( int res_id, int owner )
{
	if( res_id >= 0 && res_id < MAX_RES )
		res_owner[ res_id ] = owner;

}

void request_ownage(int action, int res_id)
{
	if(get_owner(res_id)!= action && get_owner(res_id) != AI_NONE)//
	{
		command_all( C_RELEASE, null, res_id );
	}
	if( get_owner(res_id) == AI_NONE)
		set_owner( res_id, action );
}

void zeroHomeless()
{
	if( get_owner(RES_WHEELS) == AI_NONE)
	{
		motor[BackL] = 0;
		motor[FrontL] = 0;
		motor[BackR] = 0;
		motor[FrontR] = 0;
	}
	if( get_owner(RES_ARM) == AI_NONE)
	{
		//motor[Arm] = 0;
	}
}


int isPressed( EventList *eList,  int event )
{
	for( int i=0; i < eList->eventCnt; i++ )
		if( eList->bevents[i] == event ){
		return 1;
	}
	return 0;
}



void actionArm(Command cmd, EventList *eList, int res_id )
{
	const int ARM_UP_POSITION = 100;
	const int ARM_DOWN_POSITION = 0;
	const int ARM_UP_POWER = 30;
	const int ARM_DOWN_POWER = -30;
	const int a_up = 0;
	const int a_dwn = 1;
	const int a_stop = -1;
	static int state = a_stop;
	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_ARM) == AI_ARM)
		{
			motor[arm] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionArm(C_ABORT, null, RES_ARM);
		return;
	case C_EVENT:
		request_ownage(AI_ARM , RES_ARM);

		if(get_owner(RES_ARM) == AI_ARM)
		{
			if( isPressed( eList, armUp )){
				writeDebugStreamLine("arm going up");
				motor[arm] = ARM_UP_POWER;
				ClearTimer(T2);
			}
			if( isPressed( eList, armDown ))	{
				writeDebugStreamLine("arm going down");
				motor[arm] = ARM_DOWN_POWER;
				ClearTimer(T2);
			}
			if( isPressed( eList, armStop ))	{
				motor[arm] = 0;
				state = a_stop;
			}
			if(state == a_up)
			{
				if(nMotorEncoder[arm] >= ARM_UP_POSITION || time1[T2] >= 1500)
				{
					motor[arm] = 0;
					state = a_stop;
				}
			}
			if(state == a_dwn)
			{
				if(nMotorEncoder[arm] <= ARM_DOWN_POSITION || time1[T2] >= 1500)
				{
					motor[arm] = 0;
					state = a_stop;
				}
			}


		}
		break;

	}


}

void actionRoller(Command cmd, EventList *eList, int res_id )
{
	const int UP_POWER = -50;
	const int DOWN_POWER = 50;
	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_ROLLER) == AI_ROLLER)
		{
			motor[rollers] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionRoller(C_ABORT, null, RES_ROLLER);
		return;
	case C_EVENT:
		request_ownage(AI_ROLLER , RES_ROLLER);

		if(get_owner(RES_ROLLER) == AI_ROLLER)
		{
			if( isPressed( eList, rollrStart )){
				writeDebugStreamLine("arm going up");
				motor[rollers] = UP_POWER;
			}
			if( isPressed( eList, rollrRvsStrt ))	{
				writeDebugStreamLine("arm going down");
				motor[rollers] = DOWN_POWER;
			}
			if( isPressed( eList, rollrStop ))	{
				motor[rollers] = 0;
			}
		}
		break;

	}


}

void actionGrabber(Command cmd, EventList *eList, int res_id )
{
	const int UP_POSITION = 100;
	const int DOWN_POSITION = 155;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_GRABBER) == AI_GRABBER)
		{
			//motor[Arm] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		actionGrabber(C_ABORT, null, RES_GRABBER);
		return;
	case C_EVENT:
		request_ownage(AI_GRABBER , RES_GRABBER);

		if(get_owner(RES_GRABBER) == AI_GRABBER)
		{
			if( isPressed( eList, grab )){
				servo[grabber] = DOWN_POSITION;
				//state = g_down;
				//motor[grabber] = UP_POWER;
				//nMotorEncoder[grabber] = 0;
				//ClearTimer(T1);
			}
			if( isPressed( eList, release ))	{
				servo[grabber] = UP_POSITION;
				//state = g_up;
				//motor[grabber] = DOWN_POWER;
				//nMotorEncoder[grabber] = 0;
				//ClearTimer(T1);
			}
			/*if(state==g_down)
			{
			if(nMotorEncoder[grabber] >= 0 || time1[T1] >= 2000)
			{
			motor[grabber] = 0;
			state = g_hold;
			}
			}
			if(state == g_up)
			{
			if(nMotorEncoder[grabber] <= -140 || time1[T1] >= 2000)
			{
			motor[grabber] = 0;
			state = g_hold;
			}
			}*/
		}

		break;

	}


}



void actionTRight(Command cmd, EventList *eList, int res_id)
{
	// switch cmd

}

void actionTLeft(Command cmd, EventList *eList, int res_id)
{
	// switch cmd

}
float getMultiplier(EventList *eList)
{
	static float speedMultiplier = 1.0;

	if(isPressed(eList, normalSpd))
		speedMultiplier = 1.0;
	if(isPressed(eList, lessSpd))
		speedMultiplier = 0.25;
	if(isPressed(eList, moreSpd))
		speedMultiplier= 1.80;

	return speedMultiplier;
}

void actionDrive(Command cmd, EventList *eList, int res_id )
{
	static int waitingToDrive = 0;
	static int typeDrive = 0;
	static float lefty, righty;

	switch(cmd)
	{
	case C_ABORT:
		if( get_owner(RES_WHEELS) == AI_DRIVE)
		{
			motor[BackL] = 0;
			motor[FrontL] = 0;
			motor[BackR] = 0;
			motor[FrontR] = 0;
			set_owner( res_id, AI_NONE );
			return;
		}
		break;
	case C_RELEASE:
		if(get_owner(res_id)== AI_DRIVE ){
			//stop driving
			set_owner( res_id, AI_NONE );
		}
		break;
	case C_EVENT:

		if(isPressed(eList, switchDrive))
			typeDrive = !typeDrive;

		if(get_owner(RES_WHEELS)!= AI_DRIVE && get_owner(RES_WHEELS) != AI_NONE)//request_ownage(AI_DRIVE,res_id))
		{
			command_all( C_RELEASE, null, RES_WHEELS );
		}
		if( get_owner(RES_WHEELS) == AI_NONE)
			set_owner( RES_WHEELS, AI_DRIVE );

		if(get_owner(RES_WHEELS) == AI_DRIVE)
		{
			if(typeDrive == 0)
			{
				/*if(abs(abs(((eList->joy1.y *100)/128)/2) - lefty) > abs(lefty/3))
				lefty += (((eList->joy1.y *100)/128)/2)/3;

				if(abs(abs(((eList->joy1.y *100)/128)/2) - righty) > abs(righty/3))
				righty += (((eList->joy1.y *100)/128)/2)/3;


				lefty += -((eList->joy2.x *100)/128)/2;
				righty += ((eList->joy2.x *100)/128)/2;*/

				lefty = righty = ((eList->joy1.y *100)/128);///2;


				lefty += -((eList->joy2.x *100)/128);///2;
				righty += ((eList->joy2.x *100)/128);///2;

				if(true){ //invert front
					float temp;
					temp = lefty;
					lefty = -righty;
					righty = -temp;
				}
			}
			else if(typeDrive == 1)
			{
				lefty = -((eList->joy1.y *100)/128);///2;
				righty = -((eList->joy2.y *100)/128);///2;
			}

			lefty *= (float)getMultiplier(eList);
			righty *= (float)getMultiplier(eList);

			motor[FrontL] =lefty;
			motor[BackL] = lefty;

			motor[BackR] = -righty;
			motor[FrontR] = -righty;

			//

			//motor[BackL] += -((eList->joy2.x *100)/128)/2;
			//motor[FrontL] += -((eList->joy2.x *100)/128)/2;

			//motor[BackR] += ((eList->joy2.x *100)/128)/2;
			//motor[FrontR] += ((eList->joy2.x *100)/128)/2;

			//motor[BackR] *= -1;
			//motor[FrontR] *= -1;
		}
		//


	}
}


void command_all( Command cmd, EventList *eList, int res_id )
{
	//if(res_id == RES_WHEELS)
	//{
	//	if(get_owner(res_id) != AI_DRIVE)
	//		res_owner[res_id] = AI_DRIVE;

	//	if(get_owner(res_id) == AI_DRIVE)
	//		actionDrive(cmd, eList, res_id);
	//}

	actionDrive(cmd, eList, res_id);
	actionRoller(cmd, eList, res_id);
	actionGrabber(cmd, eList, res_id);
	actionTRight( cmd, eList, res_id);
	actionTLeft( cmd, eList, res_id);
	zeroHomeless();
}


//void processAll(EventList *eList)
//{
//	if(abs(eList->joy1.y)>10 || abs(eList->joy2.x)>10
//		|| eList->bevents[1] || eList->bevents[3])
//		command_all( C_EVENT, eList, RES_WHEELS);
//	//*all the methods*(&eList);
//}

task main()
{
	EventList eList;

	clearDebugStream();
	ClearTimer(T1);
	ClearTimer(T2);
	ClearTimer(T4);

	while(1)
	{
		getEvents(&eList);
		command_all(C_EVENT, &eList, -1);
		//processDrive(&eList);

		//for(int i = 0; i<eventCnt;i++)
		//{
		//	switch(bevents[i].keyID){
		//		//case *name-of-button* :
		//		//*actions* ;
		//		//break;
		//	};
		//}



		//_________________________________________________________________________



	}
}
