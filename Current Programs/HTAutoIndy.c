#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          extend1,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          extend2,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     winch,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     arm,           tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     rollers,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#define DIST_SCALAR 349

void Stop()
{
	motor[FrontL] = 0;
	motor[BackL] = 0;
	motor[FrontR] = 0;
	motor[BackR] = 0;
	PlayTone(440, 25);
	while(1)
	{
		motor[FrontL] = 0;
		motor[BackL] = 0;
		motor[FrontR] = 0;
		motor[BackR] = 0;
	}
}


void move( float dist, float power )
{
	float deg;
	int mult;
	int lastTime, lastDegree;
	deg = (dist * DIST_SCALAR)/10; // scale from cm to motor rotations
	if( dist > 0 ) // account for backwards or forwards
		mult = 1;
	else
		mult = -1;

	float timelimit = (abs(dist)/(power/2))*10; // set a time limit based on distance

	nMotorEncoder[BackR] = 0;
	ClearTimer(T1);
	lastTime = time100[T1];
	lastDegree = nMotorEncoder[BackR];

	while(abs(nMotorEncoder[BackR]) < abs(deg))
	{
		if(time100[T1] > timelimit) // timeout if stalled
		{
			Stop();
		}

		if(lastDegree != nMotorEncoder[BackR])
		{
			lastTime = time100[T1];
			lastDegree = nMotorEncoder[BackR];
		}
		else if(time100[T1] - lastTime >= 5)
		{
			Stop();
		}

		motor[FrontL] = power * mult;
		motor[BackL] = power * mult;
		motor[FrontR] = power * mult;
		motor[BackR] = power * mult;

	}

	motor[FrontL] = 0;
	motor[BackL] = 0;
	motor[FrontR] = 0;
	motor[BackR] = 0;
}

task main()
{
	waitForStart();
	nMotorEncoder[arm] = 0;

	//move(-600, 30);
	motor[FrontL] = -20;
	motor[BackL] = -20;
	motor[FrontR] = -20;
	motor[BackR] = -20;
	wait1Msec(6000);
	motor[FrontL] = 0;
	motor[BackL] = 0;
	motor[FrontR] = 0;
	motor[BackR] = 0;


}
