#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touch,          sensorTouch)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     seeker,         sensorI2CCustom)
#pragma config(Motor,  motorA,          kicker1,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          kicker2,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     tailwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     hookwinch,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arms,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     wrist,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#include "drivers/hitechnic-irseeker-v2.h"

#define DIST_SCALAR 465

int gyroOffset = 594;			// set default value

float gyroVal = 0.0;

//*******************************************************
//*
//*	gyroCal() - This routine calcaulate the gyro offset
//*	value.
//*
//*******************************************************

int gyroCal()
{
	int sum = 0;

	// Take 50 readings and average them out
	for (int i = 0; i < 50; i++)
	{
		sum += SensorValue(S3);
		wait1Msec(5);
	}

	// Store new offset
	gyroOffset = (sum / 50.0);

	ClearTimer(T2);			// reset gyro timer

	// Return new offset value
	return gyroOffset;
}


//*******************************************************
//*
//*	updateGyro() - This routine integrates the gyro value
//*	in order to determine how far the robot has turned.
//*
//*******************************************************

float updateGyro()
{
	if( time1[T2] > 4 )
	{
		int gVal = SensorValue(S3) - gyroOffset;

		if( motor[FL] != 0 || motor[BR] != 0 )
			gyroVal += (time1[T2] * gVal) / 1000.0;

		ClearTimer(T2);	// reset gyro timer
	}
	return gyroVal;
}

//*******************************************************
//*
//*	resetGyro() - This routine reset the gryo turn value.
//*
//*******************************************************

void resetGyro()
{
	gyroVal = 0;
	ClearTimer(T2);
}

//*******************************************************
//*
//*	turn() - This routine uses the gyro to turn the robot
//*	a specified number of degrees.
//*
//*******************************************************

void turn( int deg, int power )
{
	resetGyro();
	if( deg > 0 )
		power = -1 * power;
	ClearTimer(T1);
	while( abs(gyroVal) < abs(deg)) // turn until the gyro is correct
	{
		if(time1[T1] > 3000) // timeout if stalled
			break;
		motor[FL] = power;
		motor[BL] = power;
		motor[FR] = power;
		motor[BR] = power;
		updateGyro();
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

//*******************************************************
//*
//*	move() - This routine uses the motor encoder to move the robot
//*	a specified number of centimeters.
//*
//*******************************************************

void move( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10; // scale from cm to motor rotations
	if( dist > 0 ) // account for backwards or forwards
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist); // set a time limit based on distance

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit) // timeout if stalled
			break;

		motor[FL] = -power * mult;
		motor[BL] = -power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

//*******************************************************
//*
//*	getseeker() - This routine polls the IR seeker and determines
//*	if the beacon is infront of the sensor.
//*
//*******************************************************

int getSeeker()
{
	int _dirDC = 0;
	int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	// set the DSP to the new mode
	if ( ! HTIRS2setDSPMode(seeker, DSP_1200))
		return -1; // Sensor initialized

	// Read the current non modulated signal direction
	_dirDC = HTIRS2readDCDir(seeker);
	if (_dirDC < 0)
		return -1; // I2C read error occurred

	// read the current modulated signal direction
	_dirAC = HTIRS2readACDir(seeker);
	if (_dirAC < 0)
		return -1; // I2C read error occurred

	// Read the individual signal strengths of the internal sensors
	// Do this for both unmodulated (DC) and modulated signals (AC)
	if (!HTIRS2readAllDCStrength(seeker, dcS1, dcS2, dcS3, dcS4, dcS5))
		return -1; // I2C read error occurred
	if (!HTIRS2readAllACStrength(seeker, acS1, acS2, acS3, acS4, acS5 ))
		return -1; // I2C read error occurred

	writeDebugStreamLine("D %d %d", _dirDC, _dirAC);
	writeDebugStreamLine("0 %d %d", dcS1, acS1);
	writeDebugStreamLine("1 %d %d", dcS2, acS2);
	writeDebugStreamLine("2 %d %d", dcS3, acS3);
	writeDebugStreamLine("3 %d %d", dcS4, acS4);
	writeDebugStreamLine("4 %d %d", dcS5, acS5);

	if(acS3 > 100 && acS2 < 50 && acS4 < 50) // make sure that the beacon is right in front of the sensor
		return 1;

	else
		return 0;

}

//*******************************************************
//*
//*	adjustedMove() - This routine uses the motor encoder to move the robot
//*	a specified number of centimeters while adjusting the power to make it more straight.
//*
//*******************************************************

void adjustedMove( long dist, int power )
{
	long deg;
	int mult;
	deg = (dist * DIST_SCALAR)/10; // scale from cm to motor rotations
	if( dist > 0 ) // account for backwards or forwards
		mult = 1;
	else
		mult = -1;

	int timelimit = abs(dist); // set a time limit based on distance

	nMotorEncoder[BR] = 0;
	ClearTimer(T1);
	while(abs(nMotorEncoder[BR]) < abs(deg) )
	{
		if(time100[T1] > timelimit) // timeout
			break;

		motor[FL] = -1.5 * power * mult; // adjust for differences in the motors to go straighter
		motor[BL] = -1.5 * power * mult;
		motor[FR] = power * mult;
		motor[BR] = power * mult;
	}

	motor[FL] = 0;
	motor[BL] = 0;
	motor[FR] = 0;
	motor[BR] = 0;
}

//*******************************************************
//*
//*	dump() - This routine moves so that the spatula is over the goal
//*	and dumps the block.
//*
//*******************************************************

void dump()
{
	adjustedMove(18, 20); // move to center up
	turn(90, 40);
	while(nMotorEncoder[wrist] > -400) // turn a dump
	{
		motor[wrist] = -50;
	}
	motor[wrist] = 0;
}

//*******************************************************
//*
//*	getButtons() - This routine polls the touch sensor muliplexor
//*	and retuns ench sensor's value.
//*
//*******************************************************

int* getButtons()
{
	static int buttons[] = {0,0,0,0};

	//Get touch sensor inputs
	long value = 1023-SensorRaw(S2);
	long switches = 339 * value;
	switches /= (1023-value);
	switches += 5;
	switches /= 10;
	if(switches&8)
		buttons[0] = 1;
	else
		buttons[0] = 0;
	if(switches&4)
		buttons[1] = 1;
	else
		buttons[1] = 0;
	if(switches&2)
		buttons[2] = 1;
	else
		buttons[2] = 0;
	if(switches&1)
		buttons[3] = 1;
	else
		buttons[3] = 0;
	return buttons;
}

//*******************************************************
//*
//*	IRramp() - This routine delivers the block in the goal
//*	marked by the IR beacon  and drives on the ramp.
//*
//*******************************************************

void IRramp(int left , int delay)
{
	int mult = 1;
	int beacon = 0;
	int boost = 0;

	if(left) //account for starting position
		mult = - 1;
	else
		mult = 1;
	if(delay) // wait for other team but go faster
	{
		wait1Msec(5000);
		boost = 20;
	}
	else
		boost = 0;

	if(!left)
	{
		// get intp initial position
		move(mult * 10, 20 + boost);
		turn(mult * -42, 40 + boost);

		//Raise the arm
		while(nMotorEncoder[arms] > -4900)
		{
			motor[arms] = -30;
		}
		motor[arms] = 0;

		wait10Msec(25);
	}
	else
	{
		//get into initial postion
		move(mult * 15, 20 + boost);
		turn(mult * -44, 40 + boost);
		move(-25, 20);
		wait10Msec(25);
		//raise the arm
		while(nMotorEncoder[arms] > -4900)
		{
			motor[arms] = -30;
		}
		motor[arms] = 0;

	}
	//check at each position
	if(getSeeker())
	{
		beacon = 1;
		writeDebugStreamLine("found becon at 1");
		dump();
	}

	if(!beacon)
	{
		adjustedMove(mult * 25, 20 + boost);
		wait1Msec(250);
		if(getSeeker() && !beacon)
		{
			beacon = 2;
			writeDebugStreamLine("found becon at 2");
			dump();
		}
		if(!beacon)
		{
			adjustedMove( mult * 55, 20 + boost);
			wait10Msec(25);
			if(getSeeker() && !beacon)
			{
				beacon = 3;
				writeDebugStreamLine("found becon at 3");
				dump();
			}
			if(!beacon)
			{
				adjustedMove(mult * 25, 20 + boost);
				wait10Msec(25);
				beacon = 4;
				writeDebugStreamLine("found becon at 4");
				//arived at last basket w/o sensing beacon, dump regardless
				dump();
			}
		}
	}
	wait10Msec(50);
	//decide how far to go based on position
	int add = 0;
	if(beacon == 1)
		add = 100;
	else if(beacon == 2)
		add = 75;
	else if(beacon == 3)
		add = 25;
	else
		add = 0;

	if(left)
		add += 25;

	//lift the wrist back up
	while(nMotorEncoder[wrist] < -5)
	{
		motor[wrist] = 20;
	}
	motor[wrist] = 0;


	//drive to end of baskets
	//if(left)
	//{
	//	turn(-90, 50 + boost);
	//	move(mult * (15+add), 50 + boost);

	//	while(nMotorEncoder[arms] < -250)
	//	{
	//		motor[arms] = 40;
	//	}
	//	motor[arms] = 0;
	//}
	//else
	//{
		turn(-90, 50 + boost);
		while(nMotorEncoder[arms] < -250)
		{
			motor[arms] = 40;
		}
		motor[arms] = 0;
		move(mult * (15+add), 50 + boost);
	//}
	//two-point turn in tight space
	turn(mult * 45, 50 );
	move(mult * 25, 50 + boost);
	turn(mult * 30, 50 );
	move(mult * 80, 50 + boost);
	turn(-90, 50 + boost);
	//Drive onto ramp
	move(-50, 70 + boost);
	move(-40, 90);
}

//*******************************************************
//*
//*	EndDump() - This routine delivers the block in the nearest
//*	goal and drives on the ramp.
//*
//*******************************************************

void EndDump(int left, int delay)
{
	int mult = -1;

	if(left)
		mult = 1;
	else
		mult = -1;

	int boost = 0;
	//wait for other team but go faster
	if(delay)
	{
		wait1Msec(10000);
		boost = 20;
	}

	//Raise the arm
	while(nMotorEncoder[arms] > -4900)
	{
		motor[arms] = -30;
	}
	motor[arms] = 0;

	move(20, 25 + boost); //move to goal

	while(nMotorEncoder[wrist] > -400)//dump
	{
		motor[wrist] = -50;
	}
	motor[wrist] = 0;
	wait1Msec(100);

	move(-15, 40 + boost);//back away

	while(nMotorEncoder[wrist] < -5)//raise up wrist
	{
		motor[wrist] = 20;
	}
	motor[wrist] = 0;
	while(nMotorEncoder[arms] < -250)//lower arms
	{
		motor[arms] = 40;
	}
	motor[arms] = 0;
	//drive onto ramp
	turn(mult * 90, 40 + boost);
	move(-60, 40 + boost);
	turn(mult * 70, 40 + boost);
	move(-30, 40 + boost);
	move(-70, 90);

}

//*******************************************************
//*
//*	Ramp() - This routine drives on the ramp.
//*
//*
//*******************************************************


void Ramp(int left, int delay)
{
	int mult = -1;
	if(left)
		mult = 1;
	else
		mult = -1;

	if(delay) //wait but no need to go faster
		wait1Msec(10000);

	//drive onto ramp
	move(-40, 75);
	turn(mult * -30, 75);
	move(-50, 75);
	turn(mult * 90, 75);
	move(-80, 90);
}

////////////////////////////////////////////////////////////////////////////// TASK MAIN!!! \(^0^)/
task main()
{
	clearDebugStream();
	gyroCal();
	getSeeker();
	int left = 0;
	int delay = 0;
	int endDump = 0;
	int ramp = 0;

	int* switches = getButtons();
	//asign meaning to the touch sensors
	if(switches[3])
		left = 1;
	else
		left = 0;

	if(switches[2])
		delay = 1;
	else
		delay = 0;

	if(switches[1])
		endDump = 1;
	else
		endDump = 0;

	if(switches[0])
		ramp = 1;
	else
		ramp = 0;

	//Round starts here
	waitForStart();

	nMotorEncoder[BR] = 0;
	nMotorEncoder[wrist] = 0;
	nMotorEncoder[arms] = 0;

	if(endDump)
		EndDump(left, delay);

	else if(ramp)
		Ramp(left, delay);

	else
		IRramp(left , delay);


}
