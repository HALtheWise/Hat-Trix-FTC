#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSMUX,         sensorLowSpeed)
#pragma config(Motor,  motorA,          lateralSweep,  tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          stuffer,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          verticalSweep, tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     FrontL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackR,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     rightRoller,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     leftRoller,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     car,           tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    grabberServo,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C1_2,    dropperServo,         tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    sweeperServo,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "TrackerAutoLib.h"
#include "AutoLib.h"
#include "USstuff.h"
#include "Field Positions.h"

void initializeRobot()
{
	useGoodEncoderMeasurement = true;
	initPositions();
	clearDebugStream();
	writeDebugStreamLine("GPS_centerDumpPosition1=(%d, %d, %d)", GPS_centerDumpPosition1.x, GPS_centerDumpPosition1.y, GPS_centerDumpPosition1.theta);
	gyroCal();
	//servo[dropperServo] = HOLDING_POS;
	return;
	StartTask(USmagic);

}

bool collisionMove (FieldPos target, int power, DrivingDirection forward = AutomaticDirection){
	const int BACKUP_DIST = 20;
	const int AHEAD_DIST = 80;
	 	 int SIDE_DIST = 50;
	bool succ = turnAndMoveTo(target, power, forward);

	writeDebugStreamLine("succ=%d, hitOn=%d", succ, hitOn);
	if (succ) return true;
	if (hitOn == 0) return false;

	FieldPos collisionPoint;
	copy(robot, collisionPoint);
	if (hitOn == -1) SIDE_DIST = -SIDE_DIST;
	if (lastMoveDirection == Backward) collisionPoint.theta = coerceAngle(collisionPoint.theta + PI);

	RelativePos p;
	p.x = -BACKUP_DIST * 1.5; p.y = 0;
	FieldPos target2;
	add(collisionPoint, p, target2);
	moveTo(target2, power, AutomaticDirection);

	p.x = -BACKUP_DIST; p.y = SIDE_DIST;
	add(collisionPoint, p, target2);
	moveTo(target2, power, AutomaticDirection);

	p.x = AHEAD_DIST; p.y = SIDE_DIST;
	add(collisionPoint, p, target2);
	moveTo(target2, power, AutomaticDirection);

	p.x = AHEAD_DIST * 1.5; p.y = 0;
	add(collisionPoint, p, target2);
	moveTo(target2, power, AutomaticDirection);

	return moveTo(target, power, forward);;
}

task main()
{
	initializeRobot();
	waitForStart();
	resetTracker();
	//copy(GPS_rampStartingPosition, robot);
	robot.theta = degreesToRadians(180);
	updateTRobot();
	StartTask(trackRobot); //Begin GPS tracking

	int power = 50;

	FieldPos p1;
	p1.x = 0; p1.y = 0;

	FieldPos p2;
	p2.x = 130; p2.y = 0;

	wait1Msec(3000);
	bool succ = collisionMove(p2, power, AutomaticDirection);

	wait1Msec(5000);
	turnAndMoveTo(p1, power, AutomaticDirection);



}
