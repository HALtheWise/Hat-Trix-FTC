#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          lateralSweep,  tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          stuffer,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          verticalSweep, tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     FrontL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackR,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     rightRoller,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     leftRoller,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     car,           tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    grabberServo,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C1_2,    dropperServo,         tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    sweeperServo,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "BALL-E overrides.c" //COMMENT OUT THIS LINE BEFORE RUNNING ON COMPETITION ROBOT

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "TrackerAutoLib.h"
#include "AutoLib.h"
#include "USstuff.h"
#include "Field Positions.h"
//#include "Auto GUI.h"
//#include "IRstuff.c"

//AutoMode mode = MODE_MEDIUM_ALWAYS;

#define DOLIFT1 false

void initializeRobot()
{
	initPositions();
	clearDebugStream();
	writeDebugStreamLine("GPS_centerDumpPosition1=(%d, %d, %d)", GPS_centerDumpPosition1.x, GPS_centerDumpPosition1.y, GPS_centerDumpPosition1.theta);
	gyroCal();
	servo[dropperServo] = HOLDING_POS;
	return;
}

void waitForLift(){
	if(DOLIFT1){while(!firstStageIsLifted){wait1Msec(5);}} //Wait until first stage extension has completed
	//if(DOLIFT2){while(tallArmIsMoving){wait1Msec(5);}} //Wait until second stage extension has completed
}

void rampStart(){
	const int speed_fast = 90;
	const int speed_normal = 60;
	const int speed_slower = 45;
	const int speed_precise = 35;
	const int inter_move_delay = 0;

	moveTo(GPS_offRamp, speed_slowers);
	if(DOLIFT1) liftFirstStage(true);

	//while(true){
	//	wait1Msec(1000);
	centerPos = julietUS(true);
	//}

	moveTo(GPS_almostMediumGoalPositionRamp, speed_normal);
	moveTo(GPS_mediumGoalPositionRamp, speed_precise);
	grabGoal();
}

task main()
{
	initializeRobot();
	//mode = getAutoMode();
	waitForStart(); // Wait for the beginning of autonomous phase.

	resetTracker();
	copy(GPS_rampStartingPosition, robot);
	updateTRobot();

	int startTime = nPgmTime;

	StartTask(trackRobot); //Begin GPS tracking

	rampStart();

	waitForLift();

	int dt = nPgmTime-startTime;
	writeDebugStreamLine("Ramp autonomous completed in %.2f seconds", (dt)/1000.0);
	wait1Msec(10);
}
