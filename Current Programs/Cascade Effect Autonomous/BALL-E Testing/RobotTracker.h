#pragma config(Sensor, S2,     seeker,         sensorI2CCustom)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          auxMotor,      tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          FrontL,        tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorC,          FrontR,        tmotorNXT, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "drivers/hitechnic-irseeker-v2.h"
#include "gyrostuff.h"

//---------------- Constants ----------------//

//------------- Global Variables ------------//
typedef struct {
	float x; // Measured in centimeters
	float y; // Measured in centimeters
	float theta; // Measured in counterclockwise radians
				// (0, 0, 0) is the position on the corner by the ramp facing down to the field.
				// (0, 0, pi/2) is in the same corner, facing toward the cliff
				// Positive x extends down the ramp and positive z extends off the cliff.
				// Robot positions are measured to the center of the robot's drivetrain and through the cannonical front.
} FieldPos;

FieldPos robot;

//---------- Function Declarations ----------//
void resetTracker();
float getGyro();
float getEncoder();
float angleBetween(FieldPos pos1, FieldPos pos2);
float distanceBetween(FieldPos pos1, FieldPos pos2);
float coerceAngle(float angle);

//----------- Function Definitions ----------//

float angleBetween(FieldPos pos1, FieldPos pos2){ //heading needed to go from pos1 to pos2
	float ang = atan2(pos2.y - pos1.y, pos2.x - pos1.x);
	return coerceAngle(ang);
}

float distanceBetween(FieldPos pos1, FieldPos pos2){ //
	return sqrt((pos1.x - pos2.x)*(pos1.x - pos2.x) + (pos1.y - pos2.y)*(pos1.y - pos2.y)); //Pythagorean Formula
}

float coerceAngle(float angle){
	while (angle <= -PI)  angle += 2*PI;
	while (angle >   PI)  angle -= 2*PI;
	return angle;
}

void resetTracker(){
	robot.x = 0;
	robot.y = 0;
	robot.theta = 0;
	nMotorEncoder[FrontL] = 0;
	nMotorEncoder[FrontR] = 0;
	resetGyro();
}

task dispTrack(){
	while(true){
		wait1Msec(500);
		writeDebugStreamLine("Track: (x, y, theta in deg) = (%d, %d, %f)", robot.x, robot.y, robot.theta*180/PI);
		//writeDebugStreamLine("Raw Gyro reading = %f", getGyro());
	}
}

float getEncoder(){ //Returns total average encoder distance in cm.
#ifndef SCALAR
	const float SCALAR = 3125; // Motor clicks per meter
#endif
	return (nMotorEncoder[FrontL] + nMotorEncoder[FrontR])/2.0/SCALAR*100;
}

float getGyro(){ //Returns the integrated gyro reading in counterclockwise radians
	updateGyro(false);
	return -gyroVal * PI / 180.0;
}

task trackRobot(){
	const float OVERESTIMATION_RATIO = 1+1/36.0; //The gyro seems to think it turns an extra ~10deg per full rotation.
	static float oldEncoder, oldGyro;

	//resetTracker();
	oldGyro = getGyro();
	oldEncoder = getEncoder();

	StartTask(dispTrack);
	while(true){
		wait1Msec(20); //50hz

		float dEncoder = getEncoder() - oldEncoder;
		oldEncoder += dEncoder;

		float dGyro = getGyro() - oldGyro;
		oldGyro += dGyro;

		dGyro /= OVERESTIMATION_RATIO;

		hogCPU(); //Protection against race conditions.
		robot.theta += dGyro;
		robot.theta = coerceAngle(robot.theta);

		robot.x += (cos(robot.theta)*dEncoder);
		robot.y += (sin(robot.theta)*dEncoder);
		releaseCPU();
	}
}
